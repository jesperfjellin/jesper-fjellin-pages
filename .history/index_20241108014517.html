<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jesper Fjellin's Github Pages</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/solarized-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
    <style>
        /* General Styles */
        :root {
            --primary-color: #2d3436;     /* Dark grey */
            --secondary-color: #636e72;   /* Medium grey */
            --accent-color: #0984e3;      /* Bright blue */
            --text-color: #2d3436;
            --bg-color: #ffffff;
            --card-bg: #f5f6fa;
            --shadow: 0 8px 30px rgba(0, 0, 0, 0.06);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            transition: all 0.3s ease;
            border-bottom: 1px solid transparent;
        }

        a:hover {
            color: #c0392b;  /* Darker red on hover */
            border-bottom-color: var(--secondary-color);
        }

        /* Modern Header */
        header {
            height: 100vh;
            background: linear-gradient(135deg, 
                rgba(45, 52, 54, 0.3),
                rgba(99, 110, 114, 0.3)),
                url('images/bg-header.png') center/cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .header-content {
            text-align: center;
            max-width: 800px;
            padding: 40px;
            position: relative;
        }

        .header-content::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120%;
            height: 120%;
            background: radial-gradient(circle, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0) 70%);
            z-index: -1;
        }

        .header-content h1 {
            font-size: 4.5em;
            margin: 0 0 60px 0;
            letter-spacing: -0.02em;
            color: #fff;
            background: rgba(45, 52, 54, 0.85);
            padding: 5px 25px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            display: inline-block;
            line-height: 1.2;
        }

        .title {
            font-size: 1.5em;
            color: #fff;
            margin: 0 0 40px 0;
            background: rgba(45, 52, 54, 0.85);
            padding: 3px 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            display: inline-block;
            line-height: 1.5;
        }

        .github-links {
            background: none;
            padding: 0;
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .btn {
            display: inline-block;
            padding: 10px 25px;
            background: rgba(45, 52, 54, 0.85);
            color: #fff;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            transition: var(--transition);
        }

        .btn:hover {
            background: rgba(45, 52, 54, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* Scroll Indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #fff;
        }

        .mouse {
            width: 30px;
            height: 50px;
            border: 2px solid #fff;
            border-radius: 20px;
            margin: 0 auto 10px;
            position: relative;
        }

        .mouse::before {
            content: '';
            width: 4px;
            height: 8px;
            background: #fff;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 8px;
            border-radius: 2px;
            animation: scroll 2s infinite;
        }

        /* Project Navigation */
        .project-nav {
            position: sticky;
            top: 20px;
            width: 200px;
            float: left;
        }

        .project-nav ul {
            list-style: none;
            padding: 0;
        }

        .project-nav a {
            display: block;
            padding: 15px 20px;
            color: var(--secondary-color);
            border-left: 3px solid transparent;
            transition: var(--transition);
        }

        .project-nav a.active,
        .project-nav a:hover {
            color: var(--accent-color);
            border-left-color: var(--accent-color);
            background: rgba(9, 132, 227, 0.1);
        }

        /* Projects Container */
        .projects-container {
            margin-left: 240px;
            padding: 40px 0;
        }

        .project {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 60px;
            border-left: none;
            position: relative;
            overflow: hidden;
        }

        .project::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), transparent);
        }

        .project h2 {
            font-size: 2.2em;
            color: var(--text-color);
            border-bottom: none;
            letter-spacing: -0.01em;
            margin-top: 0;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .project p {
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .project iframe {
            border: none;
            width: 100%;
            height: 400px;
            border-radius: 12px;
            margin-bottom: 10px;
            box-shadow: var(--shadow);
        }

        /* Centered Content */
        .centered-content {
            padding: 10px;
            margin: 0 auto 20px auto;
            width: 80%;
            text-align: center;
        }

        .centered-content img {
            max-width: 100%;
            border-radius: 14px;
            box-shadow: var(--shadow);
            transition: var(--transition);
            margin-top: 10px;
        }

        .centered-content img:hover {
            transform: scale(1.02);
        }

        .centered-content p {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-color);
        }

        /* Features Section */
        .features {
            margin-top: 20px;
        }

        .features h3 {
            font-size: 1.6em;
            color: var(--secondary-color);
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        .feature-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
        }

        .feature-card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .feature-card h4 {
            margin: 0 0 15px 0;
            color: var(--text-color);
            font-size: 1.2em;
        }

        .feature-card p {
            margin: 0 0 20px 0;
            color: var(--secondary-color);
        }

        .view-code-btn {
            background: none;
            border: none;
            color: var(--accent-color);
            cursor: pointer;
            font-size: 0.9em;
            padding: 0;
            transition: var(--transition);
        }

        .view-code-btn:hover {
            color: var(--secondary-color);
        }

        /* Modal Styles */
        .code-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }

        .code-modal.active {
            display: flex !important;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--card-bg);
            width: 95%;
            max-width: 1200px;
            height: 80vh;
            border-radius: 12px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        .modal-header h3 {
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: var(--secondary-color);
            transition: var(--transition);
        }

        .close-modal:hover {
            color: var(--text-color);
        }

        .modal-body {
            flex: 1;
            padding: 20px;
            overflow: hidden;  /* Hide body overflow */
        }

        .modal-body pre {
            height: 100%;
            margin: 0;
            padding: 20px;
            background: #2d2d2d;  /* Darker background */
            border-radius: 8px;
            overflow-y: scroll;
            overflow-x: auto;
            font-size: 14px;
            line-height: 1.5;
        }

        .modal-body code {
            color: #fff;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
        }

        /* Optional: Customize some Prism styles */
        .modal-body .token.comment {
            color: #6a9955;  /* Brighter green for comments */
        }

        .modal-body .token.string {
            color: #ce9178;  /* Softer orange for strings */
        }

        .modal-body .token.keyword {
            color: #569cd6;  /* Bright blue for keywords */
        }

        .modal-body .token.function {
            color: #dcdcaa;  /* Yellow for functions */
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .project-nav {
                width: 100%;
                float: none;
                position: relative;
                margin-bottom: 40px;
            }

            .project-nav ul {
                display: flex;
                overflow-x: auto;
                padding: 10px;
            }

            .projects-container {
                margin-left: 0;
            }
        }

        @keyframes scroll {
            0% { transform: translate(-50%, 0); opacity: 1; }
            100% { transform: translate(-50%, 15px); opacity: 0; }
        }

        /* Feature Cards */
        .feature-card {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            transition: var(--transition);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .feature-card h4 {
            margin: 0 0 15px 0;
            color: var(--text-color);
            font-size: 1.2em;
        }

        .feature-card p {
            margin: 0 0 20px 0;
            color: var(--secondary-color);
        }

        .view-code-btn {
            background: none;
            border: none;
            color: var(--accent-color);
            cursor: pointer;
            font-size: 0.9em;
            padding: 0;
            transition: var(--transition);
        }

        .view-code-btn:hover {
            color: var(--secondary-color);
        }

        /* Modal/Popup for code */
        .code-modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.5em;
        }

        .close-modal {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-body {
            padding: 20px;
        }

        .view-code-btn {
            display: inline-block;
            margin-top: 10px;
            color: var(--accent-color);
            text-decoration: none;
            font-size: 0.9em;
        }

        .view-code-btn:hover {
            text-decoration: underline;
        }

        /* Add this to your CSS */
        body.modal-open {
            overflow: hidden;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Jesper Fjellin</h1>
            <p class="title">GIS Developer & Engineer</p>
            <div class="github-links">
                <a href="https://github.com/jesperfjellin" target="_blank" class="btn">Personal GitHub</a>
                <a href="https://github.com/jesperfjellin-kv" target="_blank" class="btn">Work GitHub</a>
            </div>
        </div>
        <div class="scroll-indicator">
            <div class="mouse"></div>
            <span>Scroll to explore</span>
        </div>
    </header>

    <div class="container">
        <nav class="project-nav">
            <ul>
                <li><a href="#dbfriend" class="active">dbfriend</a></li>
                <li><a href="#sosilogikk">Sosilogikk</a></li>
                <li><a href="#map-extractor">Map Extractor</a></li>
            </ul>
        </nav>
        
        <div class="projects-container">
            <!-- Project 1 -->
            <div class="project">
                <h2>dbfriend - PostGIS Database Management</h2>
                <p>dbfriend is a command-line tool designed to simplify the loading and synchronization of spatial data into PostGIS databases. It focuses on data integrity and safety, ensuring that your database operations are reliable and efficient. By handling complex tasks intelligently, dbfriend helps GIS professionals and database administrators streamline their workflows.</p>
                
                <!-- Feature Cards -->
                <div class="features">
                    <h3>Key Features</h3>
                    <div class="feature-cards">
                        <div class="feature-card">
                            <h4>Transactional Operations</h4>
                            <p>All database operations are executed within transactions, ensuring data integrity and automatic rollback on failure.</p>
                            <button class="view-code-btn">View Implementation →</button>
                        </div>
                        <div class="feature-card">
                            <h4>Automated Table Backups</h4>
                            <p>dbfriend automatically creates backups before modifying any existing tables, keeping up to three historical versions per table for easy restoration and added data safety.</p>
                        </div>
                        <div class="feature-card">
                            <h4>Supports Multiple Vector Formats</h4>
                            <p>Load data from various spatial file formats, including GeoJSON, Shapefile, GeoPackage, KML, and GML, providing flexibility in handling different data sources.</p>
                        </div>
                        <div class="feature-card">
                            <h4>Intelligent Geometry Comparison</h4>
                            <p>Prevent duplicates and ensure data consistency by comparing geometries using hashes to detect new, updated, and identical features efficiently.</p>
                        </div>
                        <div class="feature-card">
                            <h4>Attribute-Aware Updates</h4>
                            <p>Update existing geometries based on attribute changes, so your database always reflects the most current data.</p>
                        </div>
                        <div class="feature-card">
                            <h4>Automatic Geometry Handling</h4>
                            <p>Automatically detects and renames geometry columns to a standard format, simplifying data processing and integration.</p>
                        </div>
                        <div class="feature-card">
                            <h4>CRS Compatibility Checks and Automatic Reprojection</h4>
                            <p>Verifies CRS compatibility and automatically reprojects data as needed, ensuring spatial data aligns correctly within your database.</p>
                        </div>
                        <div class="feature-card">
                            <h4>Spatial Index Creation for Optimized Queries</h4>
                            <p>Automatically creates spatial indexes on imported data, improving query performance and data retrieval speeds.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Project 2 -->
            <div class="project">
                <h2>Sosilogikk Python-module</h2>
                <p>Sosilogikk is a Python module intended to streamline the use of Python libraries like Shapely or Fiona for GIS analyses, on the Norwegian vector data format SOSI (Samordnet Opplegg for Stedfestet Informasjon). Sosilogikk allows the user to seamlessly load a .SOS file into a GeoPandas GeoDataFrame through only a few lines of code. <a href="https://github.com/jesperfjellin/sosilogikk" target="_blank">Github repo</a>.</p>
                
                <div class="centered-content">
                    <img src="images/SOSI-file.png" alt="Example SOSI-file">
                    <p>Example structure of a vector object in a SOSI-file. The dot- and coordinates-format makes it difficult to use with Python libraries.</p>
                </div>
            
                <div class="centered-content">
                    <img src="images/GDF_sosi.png" alt="Example SOSI-file loaded into GeoDataFrame">
                    <p>Sosilogikk applied to a large SOSI-file, resulting in an excel-like table.</p>
                </div>
            
                <p>Using the .to_file method, you can easily export the GeoDataFrame to any OGR-supported vector format, allowing software like ArcGIS or QGIS to be used.</p>
                
                <div class="centered-content">
                    <img src="images/flatgeobuf_dreneringslinjer.png" alt="Drainage lines in Flatgeobuf format visualized in QGIS" style="max-width:50%;">
                    <p>Drainage lines in Flatgeobuf format visualized in QGIS.</p>
                </div>
            </div>

            <!-- Project 3 -->
            <div class="project">
                <h2>Map Extractor: Retrieve text from PDFs</h2>
                <p>This Python script enables users to extract text information from specific regions of scanned paper maps stored as PDFs. It allows for easy selection of a Region of Interest (ROI) on one page and then scans the same area across all pages in the PDF, performing Optical Character Recognition (OCR) to extract text. The results are saved in a CSV file for easy analysis and retrieval. <a href="https://github.com/jesperfjellin/Map-Extractor" target="_blank">Github repo</a>.</p>
                
                <div class="centered-content">
                    <img src="images/OCR_map_example.png" alt="Example ROI selection">
                    <p>Example of how the region of interest selection works in the selected PDF. The red border to the center right is the ROI selector.</p>
                </div>

                <p>The output when the script is applied to the PDF above. OCR is not perfect and will need minor manual tweaks/configuring of settings in script to best suit the quality of your input PDF. Notice that the Trase string is missing an underscore between 'Trase' and the number sequence.</p>
            
                <div class="centered-content">
                    <img src="images/output_example.png" alt="Example output from map PDF">
                    <p>Example output from script.</p>
                </div>
            
                <p>The preprocess_image function is responsible for improving the accuracy OCR will have. If you are experiencing inaccurate results with Map Extractor, consider tweaking these parameters.</p>
                
                <div class="centered-content">
                    <img src="images/preprocess_image_tuning.png" alt="Settings for tuning the configuration of OCR" style="max-width:50%;">
                    <p>Preprocess_image function in the Map_Extractor.py script.</p>
                </div>
                <p>Potential further work: if you have all attributes displayed on the PDF, it should be possible to automatically create valid vector geometry from printed maps. This will require post-processing of the output data, to put it into a valid GeoJSON/GML/whatever structure, but also to clean up errors the OCR might have made. </p>
            </div>
        </div>
    </div>

    <div class="code-modal" id="code-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Implementation</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <pre><code class="hljs language-python">
                    # Set search_path before starting transaction
                    cursor = conn.cursor()
                    if args.schema:
                        cursor.execute(f"SET search_path TO {schema}, public;")
                        conn.commit()  # Commit the session setting
                    cursor.close()
                
                    # Begin transaction for all operations
                    try:
                        conn.autocommit = False
                
                        # Initialize rich Progress
                        with Progress(
                            SpinnerColumn(),
                            TextColumn("[cyan]{task.description:<30}"),
                            BarColumn(bar_width=30),
                            "[progress.percentage]{task.percentage:>3.0f}%",
                            TimeElapsedColumn(),
                            console=console,
                            expand=False
                        ) as progress:
                            task = progress.add_task("       Processing files", total=len(file_info_list))
                
                            for info in file_info_list:
                                file = info['file']
                                table_name = args.table if args.table else info['table_name']
                                qualified_table = f"{schema}.{table_name}"
                                gdf = info['gdf']
                
                                try:
                                    logger.info(f"Processing {file}")
                
                                    # Handle geometry column naming
                                    if gdf.geometry.name != 'geom':
                                        gdf = gdf.rename_geometry('geom')
                                        gdf.set_geometry('geom', inplace=True)
                                        gdf.set_crs(gdf.crs, inplace=True)
                
                                    # Ensure valid CRS
                                    if not gdf.crs:
                                        logger.warning(f"No CRS found in {file}, defaulting to EPSG:4326")
                                        gdf.set_crs(epsg=4326, inplace=True)
                
                                    if args.table:
                                        # When using --table, only keep the geometry column
                                        gdf = gdf[['geom']]
                
                                        if table_name not in existing_tables:
                                            # Get SRID from data or args
                                            srid = args.epsg if args.epsg else gdf.crs.to_epsg()
                                            if not srid:
                                                srid = 4326  # Default to WGS84 if no SRID found
                
                                            # Create table with generic geometry type and SRID
                                            if create_generic_geometry_table(conn, engine, table_name, srid, schema):
                                                existing_tables.append(table_name)
                                            else:
                                                continue
                
                                            # For new tables, all geometries are new
                                            logger.info(f"Found {format(len(gdf), ',').replace(',', ' ')} [green]new[/] geometries.")
                
                                            # Append first batch of geometries
                                            logger.info(f"Appending {format(len(gdf), ',').replace(',', ' ')} geometries to '{qualified_table}'")
                                            if append_geometries(conn, engine, gdf, table_name, schema):
                                                total_new += len(gdf)
                                        else:
                                            # Compare geometries before appending
                                            new_geoms, updated_geoms, identical_geoms = compare_geometries(
                                                gdf, conn, table_name, 'geom', schema=schema, exclude_columns=[], args=args
                                            )
                
                                            # Create summary of differences for this dataset
                                            num_new = len(new_geoms) if new_geoms is not None else 0
                                            num_updated = len(updated_geoms) if updated_geoms is not None else 0
                                            num_identical = len(identical_geoms) if identical_geoms is not None else 0
                
                                            logger.info(f"Found {format(num_new, ',').replace(',', ' ')} [green]new[/] geometries, "
                                                        f"{format(num_updated, ',').replace(',', ' ')} [yellow]updated[/] geometries, and "
                                                        f"{format(num_identical, ',').replace(',', ' ')} [red]identical[/] geometries skipped.")
                
                                            if new_geoms is not None and not new_geoms.empty:
                                                logger.info(f"Appending {format(len(new_geoms), ',').replace(',', ' ')} geometries to '{qualified_table}'")
                                                # Use schema parameter in to_postgis
                                                new_geoms.to_postgis(
                                                    name=table_name,
                                                    con=engine,
                                                    schema=schema,
                                                    if_exists='append',
                                                    index=False
                                                )
                                                total_new += len(new_geoms)
                
                                            if identical_geoms is not None:
                                                total_identical += len(identical_geoms)
                                    elif table_name in existing_tables:
                                        logger.info(f"Table {qualified_table} exists, analyzing differences...")
                
                                        # Get common columns between GDF and database table
                                        common_columns = [col for col in gdf.columns if col != 'geom']
                                        if not common_columns:
                                            # If no common columns, just compare geometries
                                            columns_sql = "MD5(ST_AsBinary(geom)) as geom_hash"
                                        else:
                                            quoted_columns = ', '.join(f'"{col}"' for col in common_columns)
                                            columns_sql = f"MD5(ST_AsBinary(geom)) as geom_hash, {quoted_columns}"
                
                                        # Check existing geometry column name in PostGIS
                                        existing_geom_col = get_db_geometry_column(conn, table_name, schema=schema)
                
                                        # Only keep 'geometry' if it's the existing column name, otherwise use 'geom'
                                        target_geom_col = 'geometry' if existing_geom_col == 'geometry' else 'geom'
                
                                        if gdf.geometry.name != target_geom_col:
                                            logger.debug(f"Renaming geometry column from '{gdf.geometry.name}' to '{target_geom_col}'")
                                            gdf = gdf.rename_geometry(target_geom_col)
                                            gdf.set_geometry(target_geom_col, inplace=True)
                                            gdf.set_crs(gdf.crs, inplace=True)  # Preserve CRS
                
                                        new_geoms, updated_geoms, identical_geoms = compare_geometries(
                                            gdf, conn, table_name, gdf.geometry.name, schema=schema, exclude_columns=exclude_cols, args=args
                                        )
                
                                        # Create summary of differences
                                        num_new = len(new_geoms) if new_geoms is not None else 0
                                        num_updated = len(updated_geoms) if updated_geoms is not None else 0
                                        num_identical = len(identical_geoms) if identical_geoms is not None else 0
                
                                        total_new += num_new
                                        total_updated += num_updated
                                        total_identical += num_identical
                
                                        logger.info(f"Found {format(num_new, ',').replace(',', ' ')} [green]new[/] geometries, "
                                                    f"{format(num_updated, ',').replace(',', ' ')} [yellow]updated[/] geometries, and "
                                                    f"{format(num_identical, ',').replace(',', ' ')} [red]identical[/] geometries skipped. "
                                                    "Skipping identical geometries...")
                
                                        # Handle new geometries
                                        if num_new > 0:
                                            try:
                                                # Use schema parameter in to_postgis
                                                new_geoms.to_postgis(
                                                    name=table_name,
                                                    con=engine,
                                                    schema=schema,
                                                    if_exists='append',
                                                    index=False
                                                )
                                                logger.info(f"Successfully appended {num_new} new geometries to {qualified_table}")
                                            except Exception as e:
                                                logger.error(f"Error appending new geometries: {e}")
                                        else:
                                            pass
                
                                        # Handle updated geometries (if implemented)
                                        if num_updated > 0:
                                            update_geometries(updated_geoms, table_name, engine, unique_id_column='osm_id')  # Adjust unique_id_column as needed
                
                                    else:
                                        num_geometries = len(gdf)
                                        logger.info(f"Found {num_geometries} new geometries to import into new table '{qualified_table}'")
                
                                        # Add coordinate printing for new tables
                                        if args.coordinates:
                                            for idx, row in gdf.iterrows():
                                                print_geometry_details(row, "NEW", args.coordinates)
                
                                        try:
                                            # Write to PostGIS with schema
                                            gdf.to_postgis(
                                                name=table_name,  # Use unqualified name
                                                con=engine,
                                                schema=schema,    # Specify schema separately
                                                if_exists='replace',
                                                index=False
                                            )
                
                                            # Verify the table was created
                                            cursor = conn.cursor()
                                            cursor.execute("""
                                                SELECT EXISTS (
                                                    SELECT 1
                                                    FROM information_schema.tables
                                                    WHERE table_schema = %s
                                                    AND table_name = %s
                                                );
                                            """, (schema, table_name))
                                            table_exists = cursor.fetchone()[0]
                                            cursor.close()
                
                                            if table_exists:
                                                logger.info(f"Successfully imported {num_geometries} geometries to new table '{qualified_table}'")
                                                create_spatial_index(conn, table_name, schema=schema, geom_column='geom')
                                                existing_tables.append(table_name)
                                                total_new += num_geometries
                                            else:
                                                logger.error(f"Failed to create table '{qualified_table}'")
                
                                        except Exception as e:
                                            logger.error(f"Error importing '{file}': {e}")
                                            continue
                
                                except Exception as e:
                                    logger.error(f"Error processing '{file}': {e}")
                                    continue
                
                                progress.advance(task)
                
                        # Commit everything at once
                        conn.commit()
                        logger.info("All changes committed successfully")
                        logger.info("Summary of tasks:\n"
                                    f"{format(total_new, ',').replace(',', ' ')} [green]new[/] geometries added, "
                                    f"{format(total_updated, ',').replace(',', ' ')} [yellow]updated[/] geometries, "
                                    f"{format(total_identical, ',').replace(',', ' ')} [red]identical[/] geometries skipped")
                
                    except Exception as e:
                        conn.rollback()  # Rollback the transaction on error
                        logger.error(f"An error occurred: {e}. All changes have been rolled back.")
                        # Optionally restore from backups here
                    finally:
                        conn.autocommit = True  # Reset autocommit
                </code></pre>
            </div>
        </div>
    </div>

    <script>
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Add click listeners to all "View Implementation" buttons
            document.querySelectorAll('.view-code-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const modal = document.getElementById('code-modal');
                    modal.classList.add('active');
                    document.body.classList.add('modal-open');
                    Prism.highlightAll();  // Highlight code when modal opens
                });
            });

            // Add click listener to close button
            document.querySelector('.close-modal').addEventListener('click', () => {
                const modal = document.getElementById('code-modal');
                modal.classList.remove('active');
                document.body.classList.remove('modal-open');  // Remove class from body
            });

            // Close modal when clicking outside
            document.querySelector('.code-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('code-modal')) {
                    e.target.classList.remove('active');
                    document.body.classList.remove('modal-open');  // Remove class from body
                }
            });
        });
    </script>
</body>
</html>